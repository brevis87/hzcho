<!-- ======= PULSE MONUMENT PARENT (HTML-–Ω–∏–∑) ======= -->
<script>
(function () {
  "use strict";

  if (window.__pulseProgParentLoaded_v12) {
    console.warn("[PULSE-PROG] duplicate load blocked (v12)");
    return;
  }
  window.__pulseProgParentLoaded_v12 = true;
  if (window.top !== window.self) return;

  const TAG = "[PULSE-PROG]";
  const PROG_KEY = "pulse_ril_progress_v1";

  // ====== –ù–ê–°–¢–†–û–ô–ö–ò (–º–µ–Ω—è–µ—à—å —Ç–æ–ª—å–∫–æ —Ç—É—Ç) ======
const TARGET_TOTAL = 5; // –æ–±—â–∞—è —Ü–µ–ª—å (–ø–æ—Å—Ç–∞–≤—å –Ω—É–∂–Ω–æ–µ —á–∏—Å–ª–æ)


const ALLOWED_ITEMS = new Set([
  "–ö–∏—Ä–ø–∏—á","–ë—É–ª—ã–∂–Ω–∏–∫"
]);

const DOUBLE_ITEMS = new Set([
  "–ü–ª–∏—Ç–∞ –∏–∑ –±–µ—Ç–æ–Ω–∞","–û–±–ª–æ–º–æ–∫ –∫–æ–ª–æ–Ω–Ω—ã"
]);

const LOG_ONLY_ITEMS = new Set([
  "—Ç–æ —á—Ç–æ –Ω–µ –∏–¥–µ—Ç –≤ –∑–∞—á–µ—Ç",
  "–¢–≤–æ–π –ø—Ä–µ–¥–º–µ—Ç 2"
]);



function pointsForItem(name){
  name = String(name||"").trim();
  if (LOG_ONLY_ITEMS.has(name)) return 0;
  if (DOUBLE_ITEMS.has(name)) return 2;
  return 1;
}




  const TOP_LIMIT = 10;          // —Å–∫–æ–ª—å–∫–æ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –≤ —Ç–æ–ø–µ
  const LOG_LIMIT = 600;         // —Å–∫–æ–ª—å–∫–æ —Ö—Ä–∞–Ω–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω–æ
  const LOG_SEND_LIMIT = 50;     // —Å–∫–æ–ª—å–∫–æ –æ—Ç–¥–∞–≤–∞—Ç—å –≤ —à–∞–ø–∫—É

  // pending/locks
  const CLICK_TS_KEY       = "pulse_ril_click_ts_v1";        // sessionStorage
  const PENDING_KEY        = "pulse_ril_pending_v1";         // localStorage
  const LOCK_KEY           = "pulse_ril_pending_lock_v1";    // localStorage
  const APPLIED_EVENTS_KEY = "pulse_ril_applied_events_v1";  // localStorage ring
  const APPLIED_LIMIT      = 500;

  const PENDING_TTL_MS = 3 * 60 * 1000;
  const LOCK_TTL_MS    = 30 * 1000;

  let IN_TAB_APPLYING = false;
  let IN_TAB_APPLYING_ID = null;

  if (typeof $ === "undefined") {
    console.error(TAG, "jQuery –Ω–µ –Ω–∞–π–¥–µ–Ω.");
    return;
  }

function safeJsonParse(s){ try { return JSON.parse(s); } catch(e){ return null; } }


function isAllowed(name){
  name = String(name||"").trim();
  return ALLOWED_ITEMS.has(name) || DOUBLE_ITEMS.has(name) || LOG_ONLY_ITEMS.has(name);
}





  // ---- API helpers ----
  async function storageGetRaw(key) {
    return new Promise((resolve) => {
      $.get("/api.php",
        { token: ForumAPITicket, method: "storage.get", app_id: 16777213, key },
        (response) => {
          if (!response || response.error || response.errors) { resolve({ ok:false, raw:null, missing:false }); return; }
          const raw = response?.response?.storage?.data?.[key];
          if (typeof raw === "undefined") { resolve({ ok:true, raw:null, missing:true }); return; }
          if (!raw || typeof raw !== "string") { resolve({ ok:false, raw:null, missing:false }); return; }
          resolve({ ok:true, raw, missing:false });
        },
        "json"
      ).fail(() => resolve({ ok:false, raw:null, missing:false }));
    });
  }

  async function storageSet(key, valueObj) {
    return new Promise((resolve) => {
      $.post("/api.php",
        { token: ForumAPITicket, method: "storage.set", app_id: 16777213, key, value: JSON.stringify(valueObj) },
        (response) => resolve(response || {}),
        "json"
      ).fail(() => resolve({ error:true }));
    });
  }

  function nowIso(){ return new Date().toISOString(); }
  function nowTs(){ return Date.now(); }

function normalizeState(p){
  const o = (p && typeof p === "object") ? p : {};
  const players = (o.players && typeof o.players === "object") ? o.players : {};
  const logs = Array.isArray(o.logs) ? o.logs : [];
  return {
    v: 3,
    points: Number(o.points || 0),
    updatedAt: Number(o.updatedAt || 0),
    last: o.last || null,
    players,
    logs
  };
}


  async function progGet() {
    const got = await storageGetRaw(PROG_KEY);
    if (got.ok && got.missing) return normalizeState({ v:3, points:0, updatedAt:0, players:{}, logs:[] });
if (!got.ok) return normalizeState({ v:3, points:0, updatedAt:0, players:{}, logs:[] });

    return normalizeState(safeJsonParse(got.raw));
  }

function buildTopPlayers(playersObj, limit){
  const arr = Object.entries(playersObj || {}).map(([name, data]) => ({
    name,
    total: Number(data?.total || 0),
    lastAt: String(data?.lastAt || "")
  }));
  arr.sort((a,b) => (b.total - a.total) || a.name.localeCompare(b.name, "ru"));
  return arr.slice(0, limit);
}


function snapshotFrom(st) {
  const points = Number(st.points || 0);

  const p = Math.max(0, Math.min(100, (points / TARGET_TOTAL) * 100));
  const completed = points >= TARGET_TOTAL;   // ‚úÖ –í–û–¢ –≠–¢–ê –°–¢–†–û–ö–ê –ù–û–í–ê–Ø

  const top = buildTopPlayers(st.players, TOP_LIMIT);
  const logs = (st.logs || []).slice(-LOG_SEND_LIMIT).reverse();

  return {
    points,
    target: TARGET_TOTAL,
    p,
    completed,               // ‚úÖ –ò –í–û–¢ –≠–¢–û –î–û–ë–ê–í–ò–õ–ò –í –û–¢–î–ê–ß–£
    updatedAt: Number(st.updatedAt || 0),
    last: st.last || null,
    topPlayers: top,
    logs
  };
}



  // ---- header bridge ----
  window.addEventListener("message", async (event) => {
    const data = event.data;
    if (!data?._pulseProgress || data.type !== "progressRequest") return;

    try {
      const st = await progGet();
      event.source.postMessage({
        _pulseProgress: true,
        type: "progressResponse",
        requestId: data.requestId,
        data: { success:true, snapshot: snapshotFrom(st) }
      }, event.origin);
    } catch (e) {
      event.source.postMessage({
        _pulseProgress: true,
        type: "progressResponse",
        requestId: data.requestId,
        data: { success:false, error: e.message }
      }, event.origin);
    }
  });

  // ---- applied ring ----
  function getAppliedList(){
    const raw = localStorage.getItem(APPLIED_EVENTS_KEY);
    const arr = raw ? safeJsonParse(raw) : null;
    return Array.isArray(arr) ? arr : [];
  }
  function hasApplied(key){ return getAppliedList().includes(key); }
  function markApplied(key){
    const arr = getAppliedList();
    arr.push(key);
    while (arr.length > APPLIED_LIMIT) arr.shift();
    localStorage.setItem(APPLIED_EVENTS_KEY, JSON.stringify(arr));
  }

  // ---- pending ----
  function setPending(name){
    const p = {
      id: (Date.now().toString(16) + Math.random().toString(16).slice(2)),
      name: String(name||"").trim(),
      ts: Date.now(),
      topicId: String(window.FORUM?.topic?.id || "0")
    };
    localStorage.setItem(PENDING_KEY, JSON.stringify(p));
    return p;
  }
  function getPending(){
    const raw = localStorage.getItem(PENDING_KEY);
    return raw ? safeJsonParse(raw) : null;
  }
  function clearPending(){ localStorage.removeItem(PENDING_KEY); }

  // ---- lock ----
  function getLock(){ return safeJsonParse(localStorage.getItem(LOCK_KEY) || "null"); }
  function setLock(obj){ localStorage.setItem(LOCK_KEY, JSON.stringify(obj || {})); }
  function clearLock(){ localStorage.removeItem(LOCK_KEY); }

  function canLock(p){
    const lock = getLock();
    if (!lock || !lock.id) return true;
    const age = Date.now() - Number(lock.ts || 0);

    if (lock.id !== p.id) return age > LOCK_TTL_MS;
    if (lock.id === p.id && lock.state === "applying") return age > LOCK_TTL_MS;
    return true;
  }

  // ---- signals from 39259.js ----
  function processLooksReal(){
    const st = sessionStorage.getItem("randomImageState");
    if (st && st !== "idle") return true;
    if (sessionStorage.getItem("randomImageFoundTime")) return true;
    if (sessionStorage.getItem("randomImagePostId")) return true;
    if (sessionStorage.getItem("randomImageTopicSubject")) return true;
    return false;
  }

  function getDropEventKey(p){
    const ft  = String(sessionStorage.getItem("randomImageFoundTime") || "").trim();
    const pid = String(sessionStorage.getItem("randomImagePostId") || "").trim();
    if (ft || pid) return (ft || "0") + "|" + (pid || "0");
    return String(p?.id || "");
  }

  // ====== –ö–õ–Æ–ß: –û–î–ò–ù –î–†–û–ü = –û–î–ò–ù SET, –°–¢–†–û–ì–û +1 ======
async function applyContribution(itemName, reason){
  const name = String(itemName||"").trim();
  if (!isAllowed(name)) return { ok:false, why:"unknown_item" };

  const add = pointsForItem(name); // 0 / 1 / 2
  const playerName = (typeof UserLogin !== "undefined" && UserLogin) ? String(UserLogin) : "Unknown";

  for (let attempt = 1; attempt <= 2; attempt++){
    const st = await progGet();

  if (Number(st.points || 0) >= TARGET_TOTAL) {
      return { ok:false, why:"completed" };
    }

const base = Number(st.points || 0);
const next = Math.min(TARGET_TOTAL, base + add); // ‚úÖ –Ω–µ –±–æ–ª—å—à–µ —Ü–µ–ª–∏


    // players (–º–µ–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ add > 0)
    const players = st.players || {};
    const cur = (players[playerName] && typeof players[playerName] === "object")
      ? players[playerName]
      : { total:0, lastAt:null };

    if (add > 0){
      players[playerName] = {
        total: Number(cur.total||0) + add,
        lastAt: nowIso()
      };
    } else {
      players[playerName] = cur; // log-only: —Ç–æ–ø –Ω–µ –º–µ–Ω—è–µ–º
    }

    // logs (–ø–∏—à–µ–º –í–°–ï–ì–î–ê)
    const logs = Array.isArray(st.logs) ? st.logs : [];
    logs.push({
      ts: nowTs(),
      at: nowIso(),
      player: playerName,
      item: name,
      add,
      reason
    });
    if (logs.length > LOG_LIMIT) logs.splice(0, logs.length - LOG_LIMIT);

    // updatedAt –æ–±–Ω–æ–≤–ª—è–µ–º –í–°–ï–ì–î–ê, —á—Ç–æ–±—ã —à–∞–ø–∫–∞ –≤–∏–¥–µ–ª–∞ "–æ–±–Ω–æ–≤–∏–ª–æ—Å—å" –ø—Ä–∏ –ª—é–±–æ–º –ø—Ä–µ–¥–º–µ—Ç–µ
    const payload = {
      v: 3,
      points: next,
      updatedAt: nowTs(),
      last: { name, add, reason, by: playerName, at: nowIso() },
      players,
      logs
    };

    const res = await storageSet(PROG_KEY, payload);
    if (res?.error || res?.errors) { await new Promise(r=>setTimeout(r, 450*attempt)); continue; }

    // –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è: –µ—Å–ª–∏ add=0, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, —á—Ç–æ –∑–∞–ø–∏—Å—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ (updatedAt –∏–∑–º–µ–Ω–∏–ª—Å—è)
    const ver = await progGet();
    if (add === 0) {
      if (Number(ver.updatedAt||0) >= Number(payload.updatedAt||0)) return { ok:true };
    } else {
      if (Number(ver.points||0) >= next) return { ok:true };
    }

    await new Promise(r=>setTimeout(r, 500*attempt));
  }

  return { ok:false, why:"failed" };
}




  // ---- long-backoff attempts (NO intervals) ----
  let __armed = false;
  function armPendingAttempts(source){
    if (__armed) return;
    __armed = true;
    const delays = [200, 700, 1500, 3000, 6000, 12000, 20000, 35000, 55000, 80000, 110000];
    delays.forEach((ms, idx) => {
      setTimeout(() => {
        tryApplyPending(source + "#"+(idx+1)).catch(()=>{});
        if (idx === delays.length - 1) __armed = false;
      }, ms);
    });
  }

  async function tryApplyPending(reason){
    const p = getPending();
    if (!p || !p.name) return;

    if (Date.now() - Number(p.ts||0) > PENDING_TTL_MS) { clearPending(); return; }
    if (!processLooksReal()) return;

    // in-tab mutex (–≥–ª–∞–≤–Ω—ã–π –∞–Ω—Ç–∏ +2/+3)
    if (IN_TAB_APPLYING && IN_TAB_APPLYING_ID === p.id) return;
    if (IN_TAB_APPLYING) return;

    if (!canLock(p)) return;

    IN_TAB_APPLYING = true;
    IN_TAB_APPLYING_ID = p.id;
    setLock({ id: p.id, ts: Date.now(), state: "applying" });

    try {
      const eventKey = getDropEventKey(p);
      if (hasApplied(eventKey)) {
        clearPending();
        setLock({ id:p.id, ts:Date.now(), state:"already_applied" });
        return;
      }

      const res = await applyContribution(p.name, reason + "|pending");

if (res.ok) {
  markApplied(eventKey);
  clearPending();
  setLock({ id:p.id, ts:Date.now(), state:"applied" });
} else if (res.why === "completed") {
  clearPending();
  setLock({ id:p.id, ts:Date.now(), state:"completed" });
  console.log(TAG, "build completed ‚Äî ignoring drops");
} else {
  clearLock();
  console.warn(TAG, "apply failed:", res.why || "unknown");
}

    } finally {
      IN_TAB_APPLYING = false;
      IN_TAB_APPLYING_ID = null;
    }
  }

  // ---- click hook ----
  document.addEventListener("click", function(ev){
    const lbl = ev.target && (ev.target.closest ? ev.target.closest(".random-image-label") : null);
    if (!lbl) return;

    const now = Date.now();
    const last = Number(sessionStorage.getItem(CLICK_TS_KEY) || 0);
    if (now - last < 250) return;
    sessionStorage.setItem(CLICK_TS_KEY, String(now));

    const img = lbl.querySelector("img");
    const itemName = String(img?.alt || img?.getAttribute("alt") || img?.title || "").trim();
    if (!itemName) return;

    setPending(itemName);
    armPendingAttempts("click");
    setTimeout(()=>{ tryApplyPending("click_fast").catch(()=>{}); }, 120);
  }, true);

  window.addEventListener("pageshow", () => armPendingAttempts("pageshow"));
  document.addEventListener("visibilitychange", () => { if (!document.hidden) armPendingAttempts("vis"); });

  armPendingAttempts("boot");

  // ---- admin helpers ----
  window.PulseProgAdmin = {
    resetAll: async function(){
      const payload = { v:3, points:0, updatedAt: nowTs(), last:{ reset:true, at: nowIso() }, players:{}, logs:[] };

      await storageSet(PROG_KEY, payload);
      localStorage.removeItem(APPLIED_EVENTS_KEY);
      localStorage.removeItem(PENDING_KEY);
      localStorage.removeItem(LOCK_KEY);
      console.log("‚úÖ", TAG, "resetAll done");
      return payload;
    },
    dump: async function(){
      const st = await progGet();
      console.log("üì¶", TAG, "dump:", st);
      return st;
    }
  };

  console.log("‚úÖ", TAG, "v12 started. Top+Log enabled, strict +1 enabled");
})();
</script>
<!-- ======= /PULSE MONUMENT PARENT ======= -->
