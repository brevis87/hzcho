



<!-- ======= PULSE MONUMENT PARENT (HTML-–Ω–∏–∑) ‚Äî v12.4 SERVER EID RING ======= -->
<script>
(function () {
  "use strict";

  if (window.__pulseProgParentLoaded_v124) {
    console.warn("[PULSE-PROG] duplicate load blocked (v12.4)");
    return;
  }
  window.__pulseProgParentLoaded_v124 = true;
  if (window.top !== window.self) return;

  const TAG = "[PULSE-PROG]";
  const PROG_KEY = "pulse_ril_progress_v1";

  // ====== –ù–ê–°–¢–†–û–ô–ö–ò ======
  const TARGET_TOTAL = 100;    // –ó–ù–ê–ß–ï–ù–ò–ï –®–ö–ê–õ–´

  const ALLOWED_ITEMS = new Set([   
    "–ê—Ä–º–∞—Ç—É—Ä–∞","–ë—É–ª—ã–∂–Ω–∏–∫","–ö–∞–±–µ–ª—å –ø–æ–¥—Å–≤–µ—Ç–∫–∏","–ö–∏—Ä–ø–∏—á","–ö—Ä–µ–ø–µ–∂–Ω—ã–µ —Å–∫–æ–±—ã","–°—Ç–∞–ª—å–Ω–∞—è –ø–ª–∞—Å—Ç–∏–Ω–∞","–û–±–ª–æ–º–æ–∫ –∫–æ–ª–æ–Ω–Ω—ã","–ë–µ—Ç–æ–Ω–Ω–∞—è –ø–ª–∏—Ç–∞","–†–∂–∞–≤–∞—è –±–∞–ª–∫–∞","–§—Ä–∞–≥–º–µ–Ω—Ç –∑–Ω–∞–º–µ–Ω–∏","–ë–æ–ª—Ç—ã","–ì–∏–ø—Å–æ–≤—ã–π —Ä–∞—Å—Ç–≤–æ—Ä","–û—Å–∫–æ–ª–æ–∫ —ç–º–±–ª–µ–º—ã","–ë–ª–æ–∫ –ø–∏—Ç–∞–Ω–∏—è","–°–≤–µ—Ç–æ–¥–∏–æ–¥","–¶–µ–º–µ–Ω—Ç","–í–µ—Ä–µ–≤–∫–∞","–°—Ç–µ–∫–ª–æ","–°–≤–µ—Ç–æ–¥–∏–æ–¥–Ω—ã–µ –±—É–∫–≤—ã","–ù–∞–±–æ—Ä –º–∞—Å—Ç–µ—Ä–∞"
  ]);

  const DOUBLE_ITEMS = new Set([      
     "–ë–æ–ª—Ç—ã","–ì–∏–ø—Å–æ–≤—ã–π —Ä–∞—Å—Ç–≤–æ—Ä","–û—Å–∫–æ–ª–æ–∫ —ç–º–±–ª–µ–º—ã","–ë–ª–æ–∫ –ø–∏—Ç–∞–Ω–∏—è","–°–≤–µ—Ç–æ–¥–∏–æ–¥","–¶–µ–º–µ–Ω—Ç" ]);  

  const LOG_ONLY_ITEMS = new Set([    
    "–í–µ—Ä–µ–≤–∫–∞","–°—Ç–µ–∫–ª–æ","–°–≤–µ—Ç–æ–¥–∏–æ–¥–Ω—ã–µ –±—É–∫–≤—ã","–ù–∞–±–æ—Ä –º–∞—Å—Ç–µ—Ä–∞"
  ]);

  function pointsForItem(name){
    name = String(name||"").trim();
    if (LOG_ONLY_ITEMS.has(name)) return 0;
    if (DOUBLE_ITEMS.has(name)) return 2;
    return 1;
  }

  const TOP_LIMIT = 100;
  const LOG_LIMIT = 2500;
  const LOG_SEND_LIMIT = 50;

  // keys
  const CLICK_TS_KEY       = "pulse_ril_click_ts_v1";        // sessionStorage
  const PENDING_KEY        = "pulse_ril_pending_v1q";        // localStorage (QUEUE)
  const LOCK_KEY           = "pulse_ril_pending_lock_v1";    // localStorage
  const APPLIED_EVENTS_KEY = "pulse_ril_applied_events_v1";  // localStorage ring
  const APPLIED_LIMIT      = 800;

  // –ª–æ–∫–∞–ª—å–Ω–∞—è ‚Äú–º–≥–Ω–æ–≤–µ–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞‚Äù –¥–ª—è —à–∞–ø–∫–∏
  const LOCAL_LAST_KEY     = "pulse_ril_local_last_v1";      // sessionStorage

  // ‚úÖ –°–ï–†–í–ï–†–ù–ê–Ø –∑–∞—â–∏—Ç–∞ –æ—Ç –¥—É–±–ª–µ–π (–æ–±—â–∞—è –¥–ª—è –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤)
  const EID_RING_LIMIT     = 1200;

  const PENDING_TTL_MS = 20 * 60 * 1000;
  const LOCK_TTL_MS    = 30 * 1000;

  let IN_TAB_APPLYING = false;
  let IN_TAB_APPLYING_ID = null;

  if (typeof $ === "undefined") {
    console.error(TAG, "jQuery –Ω–µ –Ω–∞–π–¥–µ–Ω.");
    return;
  }

  function safeJsonParse(s){ try { return JSON.parse(s); } catch(e){ return null; } }
  function nowIso(){ return new Date().toISOString(); }
  function nowTs(){ return Date.now(); }

  function ssGet(k){ try { return sessionStorage.getItem(k); } catch(e){ return null; } }
  function ssSet(k,v){ try { sessionStorage.setItem(k,String(v)); return true; } catch(e){ return false; } }

  function isAllowed(name){
    name = String(name||"").trim();
    return ALLOWED_ITEMS.has(name) || DOUBLE_ITEMS.has(name) || LOG_ONLY_ITEMS.has(name);
  }

  // ---- API helpers ----
  async function storageGetRaw(key) {
    return new Promise((resolve) => {
      $.get("/api.php",
        { token: ForumAPITicket, method: "storage.get", app_id: 16777213, key },
        (response) => {
          if (!response || response.error || response.errors) { resolve({ ok:false, raw:null, missing:false }); return; }
          const raw = response?.response?.storage?.data?.[key];
          if (typeof raw === "undefined") { resolve({ ok:true, raw:null, missing:true }); return; }
          if (!raw || typeof raw !== "string") { resolve({ ok:false, raw:null, missing:false }); return; }
          resolve({ ok:true, raw, missing:false });
        },
        "json"
      ).fail(() => resolve({ ok:false, raw:null, missing:false }));
    });
  }

  async function storageSet(key, valueObj) {
    return new Promise((resolve) => {
      $.post("/api.php",
        { token: ForumAPITicket, method: "storage.set", app_id: 16777213, key, value: JSON.stringify(valueObj) },
        (response) => resolve(response || {}),
        "json"
      ).fail(() => resolve({ error:true, status:503 }));
    });
  }

  function normalizeState(p){
    const o = (p && typeof p === "object") ? p : {};
    const players = (o.players && typeof o.players === "object") ? o.players : {};
    const logs = Array.isArray(o.logs) ? o.logs : [];
    const eidRing = Array.isArray(o.eidRing) ? o.eidRing : [];
    return {
      v: 4,
      points: Number(o.points || 0),
      updatedAt: Number(o.updatedAt || 0),
      last: o.last || null,
      players,
      logs,
      eidRing
    };
  }

async function progGet() {
  const got = await storageGetRaw(PROG_KEY);

  // ‚úÖ –∫–ª—é—á —Ä–µ–∞–ª—å–Ω–æ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Üí —Å—Ç–∞—Ä—Ç—É–µ–º —Å –Ω—É–ª—è
  if (got.ok && got.missing) {
    return normalizeState({ v:4, points:0, updatedAt:0, players:{}, logs:[], eidRing:[] });
  }

  // ‚ùå –æ—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è (503/—Ç–∞–π–º–∞—É—Ç/–æ—à–∏–±–∫–∞ API) ‚Üí –ù–ï –≤–æ–∑–≤—Ä–∞—â–∞–µ–º 0, –∞ —Å–∏–≥–Ω–∞–ª–∏–º –æ—à–∏–±–∫—É
  if (!got.ok) {
    return null; // –≤–∞–∂–Ω–æ!
  }

  return normalizeState(safeJsonParse(got.raw));
}


  function buildTopPlayers(playersObj, limit){
    const arr = Object.entries(playersObj || {}).map(([name, data]) => ({
      name,
      total: Number(data?.total || 0),
      lastAt: String(data?.lastAt || "")
    }));
    arr.sort((a,b) => (b.total - a.total) || a.name.localeCompare(b.name, "ru"));
    return arr.slice(0, limit);
  }

  function snapshotFrom(st) {
    const points = Number(st.points || 0);
    const p = Math.max(0, Math.min(100, (points / TARGET_TOTAL) * 100));
    const completed = points >= TARGET_TOTAL;
    const top = buildTopPlayers(st.players, TOP_LIMIT);
    const logs = (st.logs || []).slice(-LOG_SEND_LIMIT).reverse();
    return { points, target: TARGET_TOTAL, p, completed, updatedAt: Number(st.updatedAt || 0), last: st.last || null, topPlayers: top, logs };
  }

  // ---- header bridge ----
  window.addEventListener("message", async (event) => {
    const data = event.data;
    if (!data?._pulseProgress || data.type !== "progressRequest") return;
    try {


if (!event.source || !event.source.postMessage) return;
  const st = await progGet();

  if (!st) {
    event.source.postMessage({
      _pulseProgress: true,
      type: "progressResponse",
      requestId: data.requestId,
      data: { success:false, error:"storage_get_failed" }
    }, event.origin);
    return;
  }

  event.source.postMessage({
    _pulseProgress: true,
    type: "progressResponse",
    requestId: data.requestId,
    data: { success:true, snapshot: snapshotFrom(st) }
  }, event.origin);
} catch (e) {
  event.source.postMessage({
    _pulseProgress: true,
    type: "progressResponse",
    requestId: data.requestId,
    data: { success:false, error: e.message }
  }, event.origin);
}

  });

  // ---- applied ring (local) ----
  function getAppliedList(){
    const raw = localStorage.getItem(APPLIED_EVENTS_KEY);
    const arr = raw ? safeJsonParse(raw) : null;
    return Array.isArray(arr) ? arr : [];
  }
  function hasApplied(key){ return getAppliedList().includes(key); }
  function markApplied(key){
    const arr = getAppliedList();
    arr.push(key);
    while (arr.length > APPLIED_LIMIT) arr.shift();
    localStorage.setItem(APPLIED_EVENTS_KEY, JSON.stringify(arr));
  }

  // ---- QUEUE pending ----
  function getQueue(){
    const raw = localStorage.getItem(PENDING_KEY);
    const arr = raw ? safeJsonParse(raw) : null;
    return Array.isArray(arr) ? arr : [];
  }
  function setQueue(q){
    if (!q || !q.length) localStorage.removeItem(PENDING_KEY);
    else localStorage.setItem(PENDING_KEY, JSON.stringify(q));
  }

  function pushPending(name, eid){
    const p = {
      id: (Date.now().toString(16) + Math.random().toString(16).slice(2)),
      name: String(name||"").trim(),
      ts: Date.now(),
      topicId: String(window.FORUM?.topic?.id || "0"),
      eid: String(eid || "")
    };
    const q = getQueue();
    q.push(p);
    while (q.length > 30) q.shift();
    setQueue(q);
    return p;
  }
  function peekPending(){ const q = getQueue(); return q.length ? q[0] : null; }
  function shiftPending(){ const q = getQueue(); if (!q.length) return; q.shift(); setQueue(q); }

  // ---- lock ----
  function getLock(){ return safeJsonParse(localStorage.getItem(LOCK_KEY) || "null"); }
  function setLock(obj){ localStorage.setItem(LOCK_KEY, JSON.stringify(obj || {})); }
  function clearLock(){ localStorage.removeItem(LOCK_KEY); }
  function canLock(p){
    const lock = getLock();
    if (!lock || !lock.id) return true;
    const age = Date.now() - Number(lock.ts || 0);
    if (age > LOCK_TTL_MS) return true;
    if (lock.id !== p.id) return false;
    return true;
  }

  // ---- —Å—Ç–∞–±–∏–ª—å–Ω—ã–π eventKey ----
  function makeEventIdForClick(itemName){
    const ft  = String(ssGet("randomImageFoundTime") || "").trim();
    const pid = String(ssGet("randomImagePostId") || "").trim();
    const tid = String(window.FORUM?.topic?.id || "0");
    const nm  = String(itemName || "").trim();

    // –µ—Å–ª–∏ drop-—Å–∫—Ä–∏–ø—Ç –¥–∞–ª –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã ‚Äî —ç—Ç–æ –ª—É—á—à–∏–π –∫–ª—é—á
    if (ft || pid) return `${tid}|${ft||"0"}|${pid||"0"}|${nm}`;

    // fallback: ‚Äú–±–∞–∫–µ—Ç‚Äù 2 —Å–µ–∫—É–Ω–¥—ã, —á—Ç–æ–±—ã –æ–¥–Ω–∞ –∏ —Ç–∞ –∂–µ –∫–∞—Ä—Ç–∏–Ω–∫–∞ –Ω–µ –¥–∞–≤–∞–ª–∞ 2 —Ä–∞–∑–Ω—ã—Ö eid –æ—Ç –¥–≤–æ–π–Ω–æ–≥–æ –∫–ª–∏–∫–∞
    const bucket = Math.floor(Date.now()/2000);
    return `${tid}|${nm}|${bucket}`;
  }

  function getDropEventKey(p){
    const eid = String(p?.eid || "").trim();
    if (eid) return eid;
    return String(p?.topicId || "0") + "|" + String(p?.id || "");
  }

  function broadcastForceRefresh(){
    try { window.postMessage({ _pulseProgress:true, type:"forceRefresh" }, "*"); } catch(e){}
  }

  // ===== apply (—Å–µ—Ä–≤–µ—Ä–Ω–∞—è –∞–Ω—Ç–∏-–¥—É–±–ª—å —á–µ—Ä–µ–∑ eidRing) =====
  async function applyContribution(itemName, reason, eventId){
    const name = String(itemName||"").trim();
    if (!isAllowed(name)) return { ok:false, why:"unknown_item" };

    const add = pointsForItem(name);
    const playerName = (typeof UserLogin !== "undefined" && UserLogin) ? String(UserLogin) : "Unknown";
    const eid = String(eventId || "").trim();

    for (let attempt = 1; attempt <= 3; attempt++){
      const st = await progGet();

if (!st) {
  await new Promise(r => setTimeout(r, 400 * attempt));
  continue;
}

// ‚úÖ –≤–µ—Ä–Ω—É—Ç—å!
if (eid && st.eidRing && st.eidRing.includes(eid)) {
  return { ok:true, why:"already_in_eidRing" };
}



     if (Number(st.points || 0) >= TARGET_TOTAL) return { ok:false, why:"completed" };

      const base = Number(st.points || 0);
      const next = Math.min(TARGET_TOTAL, base + add);

      const players = st.players || {};
      const cur = (players[playerName] && typeof players[playerName] === "object")
        ? players[playerName]
        : { total:0, lastAt:null };

      if (add > 0){
        players[playerName] = { total: Number(cur.total||0) + add, lastAt: nowIso() };
      } else {
        players[playerName] = cur;
      }

      const logs = Array.isArray(st.logs) ? st.logs : [];
      logs.push({ ts: nowTs(), at: nowIso(), player: playerName, item: name, add, reason, eid: eid || null });
      if (logs.length > LOG_LIMIT) logs.splice(0, logs.length - LOG_LIMIT);

      // eidRing –æ–±–Ω–æ–≤–ª—è–µ–º –≤—Å–µ–≥–¥–∞ –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–π –∑–∞–ø–∏—Å–∏ (–µ—Å–ª–∏ eid –µ—Å—Ç—å)
      const eidRing = Array.isArray(st.eidRing) ? st.eidRing.slice() : [];
      if (eid){
        eidRing.push(eid);
        while (eidRing.length > EID_RING_LIMIT) eidRing.shift();
      }

      const payload = {
        v: 4,
        points: next,
        updatedAt: nowTs(),
        last: { name, add, reason, by: playerName, at: nowIso(), eid: eid || null },
        players,
        logs,
        eidRing
      };

      const res = await storageSet(PROG_KEY, payload);
      if (res?.error || res?.errors) {
        // 503/–æ—à–∏–±–∫–∏ ‚Äî –ø–∞—É–∑–∞ –∏ –ø–æ–≤—Ç–æ—Ä
        await new Promise(r=>setTimeout(r, 500*attempt));
        continue;
      }

      // –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è
      const ver = await progGet();
if (!ver) { await new Promise(r=>setTimeout(r, 250*attempt)); continue; }

// ‚úÖ –≤–µ—Ä–Ω—É—Ç—å!
if (eid && ver.eidRing && ver.eidRing.includes(eid)) return { ok:true, add };


      if (!eid) {
        // fallback: –∫–∞–∫ —Ä–∞–Ω—å—à–µ
        if (add === 0) {
          if (Number(ver.updatedAt||0) >= Number(payload.updatedAt||0)) return { ok:true, add };
        } else {
          if (Number(ver.points||0) >= next) return { ok:true, add };
        }
      }

      await new Promise(r=>setTimeout(r, 300*attempt));
    }

    return { ok:false, why:"failed" };
  }

  // ---- attempts ----
  let __armed = false;
  function armPendingAttempts(source){
    if (__armed) return;
    __armed = true;
    const delays = [200, 700, 1500, 3000, 6000, 12000, 20000, 35000, 55000];
    delays.forEach((ms, idx) => {
      setTimeout(() => {
        tryApplyPending(source + "#"+(idx+1)).catch(()=>{});
        if (idx === delays.length - 1) __armed = false;
      }, ms);
    });
  }

  async function tryApplyPending(reason){
    const p = peekPending();
    if (!p || !p.name) return;

    if (Date.now() - Number(p.ts||0) > PENDING_TTL_MS) { shiftPending(); return; }

    if (IN_TAB_APPLYING && IN_TAB_APPLYING_ID === p.id) return;
    if (IN_TAB_APPLYING) return;
    if (!canLock(p)) return;

    IN_TAB_APPLYING = true;
    IN_TAB_APPLYING_ID = p.id;
    setLock({ id: p.id, ts: Date.now(), state: "applying" });

    try {
      const eventKey = getDropEventKey(p);

      // –ª–æ–∫–∞–ª—å–Ω—ã–π applied ‚Äî –±—ã—Å—Ç—Ä—ã–π –æ—Ç–±–æ–π
      if (hasApplied(eventKey)) {
        shiftPending();
        setTimeout(()=>{ tryApplyPending("queue_next").catch(()=>{}); }, 60);
        return;
      }

      const res = await applyContribution(p.name, String(reason||"") + "|pending", eventKey);

      if (res.ok) {
        markApplied(eventKey);
        shiftPending();
        setLock({ id:p.id, ts:Date.now(), state:"applied" });

        // ‚úÖ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –ø—Ä–æ—Å–∏–º —à–∞–ø–∫—É –æ–±–Ω–æ–≤–∏—Ç—å—Å—è
        broadcastForceRefresh();

        // ‚úÖ –ø—Ä–∏–º–µ–Ω—è–µ–º —Å–ª–µ–¥—É—é—â–∏–π
        setTimeout(()=>{ tryApplyPending("queue_next").catch(()=>{}); }, 60);
      } else if (res.why === "completed") {
        shiftPending();
        setLock({ id:p.id, ts:Date.now(), state:"completed" });
      } else {
        clearLock();
        console.warn(TAG, "apply failed:", res.why || "unknown");
      }
    } finally {
      IN_TAB_APPLYING = false;
      IN_TAB_APPLYING_ID = null;
    }
  }

  // ---- click hook ----
  document.addEventListener("click", function(ev){
    const lbl = ev.target && (ev.target.closest ? ev.target.closest(".random-image-label") : null);
    if (!lbl) return;

    const now = Date.now();
    const last = Number(ssGet(CLICK_TS_KEY) || 0);
    if (now - last < 250) return;
    ssSet(CLICK_TS_KEY, String(now));

    const img = lbl.querySelector("img");
    const itemName = String(img?.alt || img?.getAttribute("alt") || img?.title || "").trim();
    if (!itemName) return;

    const eid = makeEventIdForClick(itemName);

    // ‚úÖ –ª–æ–∫–∞–ª—å–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º ‚Äú–º–≥–Ω–æ–≤–µ–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É‚Äù –≤ —à–∞–ø–∫–µ (–ø–æ–∫–∞ API –ø–∏—à–µ—Ç)
    ssSet(LOCAL_LAST_KEY, JSON.stringify({
      ts: Date.now(),
      player: (typeof UserLogin !== "undefined" && UserLogin) ? String(UserLogin) : "Unknown",
      item: itemName,
      eid
    }));
    broadcastForceRefresh();

    pushPending(itemName, eid);
    armPendingAttempts("click");
    setTimeout(()=>{ tryApplyPending("click_fast").catch(()=>{}); }, 120);
  }, true);

  window.addEventListener("pageshow", () => armPendingAttempts("pageshow"));
  document.addEventListener("visibilitychange", () => { if (!document.hidden) armPendingAttempts("vis"); });
  armPendingAttempts("boot");

  // ---- admin helpers ----
  window.PulseProgAdmin = {
    resetAll: async function(){
      const payload = { v:4, points:0, updatedAt: nowTs(), last:{ reset:true, at: nowIso(), eid:null }, players:{}, logs:[], eidRing:[] };
      await storageSet(PROG_KEY, payload);
      localStorage.removeItem(APPLIED_EVENTS_KEY);
      localStorage.removeItem(PENDING_KEY);
      localStorage.removeItem(LOCK_KEY);
      console.log("‚úÖ", TAG, "resetAll done");
      return payload;
    },
    dump: async function(){
      const st = await progGet();
      console.log("üì¶", TAG, "dump:", st);
      return st;
    }
  };

  console.log("‚úÖ", TAG, "v12.4 started (SERVER eidRing anti-dupes + fast refresh + local preview)");
})();
</script>
<!-- ======= /PULSE MONUMENT PARENT ======= -->
